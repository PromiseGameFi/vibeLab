import { execSync } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { requireFoundry, getDefaultRpc, getForkBlock } from './utils';

export interface ExploitResult {
    testName: string;
    passed: boolean;
    output: string;
    gasUsed?: string;
}

const FOUNDRY_PROJECT_DIR = path.join(process.cwd(), '.vibeaudit-exploits');

/**
 * Initialize a temporary Foundry project for running exploit tests.
 */
async function initFoundryProject(): Promise<void> {
    try {
        await fs.access(FOUNDRY_PROJECT_DIR);
        // Already exists ‚Äî clear old tests
        const testDir = path.join(FOUNDRY_PROJECT_DIR, 'test');
        try {
            const files = await fs.readdir(testDir);
            for (const file of files) {
                await fs.unlink(path.join(testDir, file));
            }
        } catch { /* test dir might not exist yet */ }
        return;
    } catch {
        // Does not exist ‚Äî create it
    }

    console.log(chalk.cyan('üì¶ Initializing Foundry exploit workspace...'));

    await fs.mkdir(FOUNDRY_PROJECT_DIR, { recursive: true });

    // Create foundry.toml
    const toml = `[profile.default]
src = "src"
out = "out"
libs = ["lib"]
test = "test"

[rpc_endpoints]
mainnet = "\${RPC_URL}"
`;
    await fs.writeFile(path.join(FOUNDRY_PROJECT_DIR, 'foundry.toml'), toml);

    // Create directories
    await fs.mkdir(path.join(FOUNDRY_PROJECT_DIR, 'src'), { recursive: true });
    await fs.mkdir(path.join(FOUNDRY_PROJECT_DIR, 'test'), { recursive: true });
    await fs.mkdir(path.join(FOUNDRY_PROJECT_DIR, 'lib'), { recursive: true });

    // Install forge-std
    try {
        execSync('forge install foundry-rs/forge-std --no-commit', {
            cwd: FOUNDRY_PROJECT_DIR,
            stdio: 'pipe',
        });
    } catch {
        // If git not init, init first
        try {
            execSync('git init', { cwd: FOUNDRY_PROJECT_DIR, stdio: 'pipe' });
            execSync('forge install foundry-rs/forge-std --no-commit', {
                cwd: FOUNDRY_PROJECT_DIR,
                stdio: 'pipe',
            });
        } catch (e) {
            console.error(chalk.yellow('‚ö†Ô∏è  Could not install forge-std. Tests may fail.'));
        }
    }

    console.log(chalk.green('‚úÖ Foundry workspace ready.'));
}

/**
 * Copy a target contract's source into the exploit workspace.
 */
async function copyTargetSource(sourcePath: string): Promise<void> {
    const srcDir = path.join(FOUNDRY_PROJECT_DIR, 'src');
    const filename = path.basename(sourcePath);
    const content = await fs.readFile(sourcePath, 'utf-8');
    await fs.writeFile(path.join(srcDir, filename), content);
}

/**
 * Write a target contract's source code directly into the exploit workspace.
 */
async function writeTargetSource(filename: string, code: string): Promise<void> {
    const srcDir = path.join(FOUNDRY_PROJECT_DIR, 'src');
    await fs.writeFile(path.join(srcDir, filename), code);
}

/**
 * Run exploit tests and return results.
 *
 * @param exploitCode - Full Solidity test contract code
 * @param testFileName - Name for the test file (e.g., "ReentrancyExploit.t.sol")
 * @param rpcUrl - RPC URL for fork testing
 * @param targetSourcePath - Optional path to the target .sol file to copy into the workspace
 * @param targetSourceCode - Optional source code to write directly (for on-chain contracts)
 * @param targetSourceName - Filename for the source code (used with targetSourceCode)
 */
export async function runExploit(options: {
    exploitCode: string;
    testFileName: string;
    rpcUrl?: string;
    targetSourcePath?: string;
    targetSourceCode?: string;
    targetSourceName?: string;
}): Promise<ExploitResult[]> {
    requireFoundry();

    const rpc = options.rpcUrl || getDefaultRpc();
    const forkBlock = getForkBlock();

    await initFoundryProject();

    // Copy or write target source
    if (options.targetSourcePath) {
        await copyTargetSource(options.targetSourcePath);
    }
    if (options.targetSourceCode && options.targetSourceName) {
        await writeTargetSource(options.targetSourceName, options.targetSourceCode);
    }

    // Write exploit test file
    const testDir = path.join(FOUNDRY_PROJECT_DIR, 'test');
    const testFilePath = path.join(testDir, options.testFileName);
    await fs.writeFile(testFilePath, options.exploitCode);

    console.log(chalk.cyan(`‚öîÔ∏è  Running exploit: ${options.testFileName}...`));

    // Run forge test
    let forgeCmd = `forge test --match-path test/${options.testFileName} -vvv`;
    if (rpc && rpc !== 'none') {
        forgeCmd += ` --fork-url ${rpc}`;
        if (forkBlock !== 'latest') {
            forgeCmd += ` --fork-block-number ${forkBlock}`;
        }
    }

    try {
        const output = execSync(forgeCmd, {
            cwd: FOUNDRY_PROJECT_DIR,
            stdio: 'pipe',
            timeout: 120000, // 2 minute timeout
            env: { ...process.env, RPC_URL: rpc },
        }).toString();

        return parseForgeOutput(output, options.testFileName);
    } catch (error: any) {
        const output = error.stdout?.toString() || error.stderr?.toString() || error.message;
        // Even on failure, forge outputs test results
        const results = parseForgeOutput(output, options.testFileName);
        if (results.length > 0) return results;

        return [{
            testName: options.testFileName,
            passed: false,
            output: `Forge execution failed:\n${output.substring(0, 2000)}`,
        }];
    }
}

/**
 * Parse forge test output into structured results.
 */
function parseForgeOutput(output: string, testFileName: string): ExploitResult[] {
    const results: ExploitResult[] = [];
    const lines = output.split('\n');

    for (const line of lines) {
        // Match lines like: [PASS] testExploit() (gas: 123456)
        const passMatch = line.match(/\[PASS\]\s+(\w+)\(\)\s*(?:\(gas:\s*(\d+)\))?/);
        if (passMatch) {
            results.push({
                testName: passMatch[1],
                passed: true,
                output: line.trim(),
                gasUsed: passMatch[2],
            });
            continue;
        }

        // Match lines like: [FAIL] testExploit() ...
        const failMatch = line.match(/\[FAIL[.\s]*\]\s+(\w+)\(\)/);
        if (failMatch) {
            results.push({
                testName: failMatch[1],
                passed: false,
                output: line.trim(),
            });
        }
    }

    // If no specific test results found, create a generic one
    if (results.length === 0) {
        const hasPass = output.includes('[PASS]');
        const hasFail = output.includes('[FAIL');
        results.push({
            testName: testFileName,
            passed: hasPass && !hasFail,
            output: output.substring(0, 2000),
        });
    }

    return results;
}

/**
 * Run multiple exploit tests in sequence and collect all results.
 */
export async function runAllExploits(exploits: {
    code: string;
    name: string;
    rpcUrl?: string;
    targetSourcePath?: string;
    targetSourceCode?: string;
    targetSourceName?: string;
}[]): Promise<{ name: string; results: ExploitResult[] }[]> {
    const allResults: { name: string; results: ExploitResult[] }[] = [];

    for (let i = 0; i < exploits.length; i++) {
        const exploit = exploits[i];
        console.log(chalk.blue(`\n[${i + 1}/${exploits.length}] Running: ${exploit.name}`));

        try {
            const results = await runExploit({
                exploitCode: exploit.code,
                testFileName: `Exploit${i + 1}_${sanitizeFilename(exploit.name)}.t.sol`,
                rpcUrl: exploit.rpcUrl,
                targetSourcePath: exploit.targetSourcePath,
                targetSourceCode: exploit.targetSourceCode,
                targetSourceName: exploit.targetSourceName,
            });

            allResults.push({ name: exploit.name, results });

            for (const r of results) {
                if (r.passed) {
                    console.log(chalk.red(`   üíÄ EXPLOIT CONFIRMED: ${r.testName} PASSED`));
                } else {
                    console.log(chalk.gray(`   ‚ùå ${r.testName} failed (false positive or needs adjustment)`));
                }
            }
        } catch (error) {
            console.error(chalk.yellow(`   ‚ö†Ô∏è  Exploit ${exploit.name} threw: ${(error as Error).message}`));
            allResults.push({
                name: exploit.name,
                results: [{ testName: exploit.name, passed: false, output: (error as Error).message }],
            });
        }
    }

    return allResults;
}

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9]/g, '').substring(0, 30);
}
