/**
 * Exploit Simulator â€” Fork-Based Vulnerability Testing
 * 
 * Generates Foundry test scenarios from analysis findings, runs them
 * against a forked chain, and reports confirmed/denied vulnerabilities.
 * No real transactions are ever broadcast.
 */

import { execSync, exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import OpenAI from 'openai';
import dotenv from 'dotenv';
import { ContractIntel, getAnalyzableCode } from './intel-gatherer';

dotenv.config();

let _openai: OpenAI | null = null;
function getOpenAI(): OpenAI {
    if (!_openai) {
        _openai = new OpenAI({
            apiKey: process.env.OPENROUTER_API_KEY || 'dummy',
            baseURL: 'https://openrouter.ai/api/v1',
            defaultHeaders: {
                'HTTP-Referer': 'https://vibelab.app',
                'X-Title': 'VibeAudit',
            },
        });
    }
    return _openai;
}

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface VulnerabilityFinding {
    id: string;
    category: string;       // e.g. "reentrancy", "access-control", "integer-overflow"
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
    title: string;
    description: string;
    affectedFunction?: string;
    recommendation?: string;
}

export interface SimulationResult {
    finding: VulnerabilityFinding;
    testCode: string;
    passed: boolean;            // true = exploit worked = vulnerability confirmed
    output: string;             // Forge stdout/stderr
    gasUsed?: number;
    error?: string;
    duration: number;           // ms
}

export interface SimulationReport {
    contractAddress: string;
    chain: string;
    rpcUrl: string;
    findings: VulnerabilityFinding[];
    simulations: SimulationResult[];
    confirmedVulnerabilities: number;
    deniedVulnerabilities: number;
    totalDuration: number;
    timestamp: string;
}

// â”€â”€â”€ Foundry Project Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SIMULATION_DIR = path.join(process.cwd(), '.vibeaudit-agent', 'simulations');

function ensureSimulationDir(): string {
    if (!fs.existsSync(SIMULATION_DIR)) {
        fs.mkdirSync(SIMULATION_DIR, { recursive: true });
    }

    // Create foundry project structure if needed
    const srcDir = path.join(SIMULATION_DIR, 'src');
    const testDir = path.join(SIMULATION_DIR, 'test');

    if (!fs.existsSync(srcDir)) fs.mkdirSync(srcDir, { recursive: true });
    if (!fs.existsSync(testDir)) fs.mkdirSync(testDir, { recursive: true });

    // Write foundry.toml if missing
    const tomlPath = path.join(SIMULATION_DIR, 'foundry.toml');
    if (!fs.existsSync(tomlPath)) {
        fs.writeFileSync(tomlPath, `[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc-version = "0.8.24"
evm_version = "cancun"

[fuzz]
runs = 256

[rpc_endpoints]
mainnet = "\${RPC_URL}"
`);
    }

    // Install forge-std if needed
    const forgeStd = path.join(SIMULATION_DIR, 'lib', 'forge-std');
    if (!fs.existsSync(forgeStd)) {
        try {
            execSync('forge install foundry-rs/forge-std --no-commit', {
                cwd: SIMULATION_DIR,
                timeout: 30000,
                stdio: 'pipe',
            });
        } catch (err) {
            // Git init might fail, try manual approach
            try {
                execSync('git init && forge install foundry-rs/forge-std --no-commit', {
                    cwd: SIMULATION_DIR,
                    timeout: 30000,
                    stdio: 'pipe',
                });
            } catch {
                console.log(chalk.yellow('   âš  Could not install forge-std. Simulations may fail.'));
            }
        }
    }

    return testDir;
}

// â”€â”€â”€ Foundry Availability â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function isFoundryInstalled(): boolean {
    try {
        execSync('forge --version', { stdio: 'pipe', timeout: 5000 });
        return true;
    } catch {
        return false;
    }
}

// â”€â”€â”€ Main Simulation Pipeline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function simulateExploits(
    intel: ContractIntel,
    findings: VulnerabilityFinding[],
    rpcUrl: string,
): Promise<SimulationReport> {
    const startTime = Date.now();

    const report: SimulationReport = {
        contractAddress: intel.address,
        chain: intel.chain,
        rpcUrl,
        findings,
        simulations: [],
        confirmedVulnerabilities: 0,
        deniedVulnerabilities: 0,
        totalDuration: 0,
        timestamp: new Date().toISOString(),
    };

    // Check if Foundry is available
    if (!isFoundryInstalled()) {
        console.log(chalk.yellow('   âš  Foundry not installed â€” skipping fork simulations'));
        console.log(chalk.gray('     Install: curl -L https://foundry.paradigm.xyz | bash'));
        report.totalDuration = Date.now() - startTime;
        return report;
    }

    // Filter to testable findings (CRITICAL/HIGH/MEDIUM with concrete attack vectors)
    const testable = findings.filter(f =>
        ['CRITICAL', 'HIGH', 'MEDIUM'].includes(f.severity) &&
        f.category !== 'info' &&
        f.category !== 'best-practice',
    );

    if (testable.length === 0) {
        console.log(chalk.gray('   No testable findings to simulate'));
        report.totalDuration = Date.now() - startTime;
        return report;
    }

    console.log(chalk.cyan(`   ðŸ§ª Simulating ${testable.length} findings against fork...`));

    const testDir = ensureSimulationDir();
    const code = getAnalyzableCode(intel);

    // Generate and run tests sequentially (Forge locks the project)
    for (const finding of testable) {
        try {
            const result = await simulateSingleFinding(
                finding,
                intel,
                code,
                rpcUrl,
                testDir,
            );

            report.simulations.push(result);

            if (result.passed) {
                report.confirmedVulnerabilities++;
                console.log(chalk.red(`     âœ— CONFIRMED: ${finding.title}`));
            } else {
                report.deniedVulnerabilities++;
                console.log(chalk.green(`     âœ“ NOT EXPLOITABLE: ${finding.title}`));
            }
        } catch (err) {
            const error = err as Error;
            report.simulations.push({
                finding,
                testCode: '',
                passed: false,
                output: error.message,
                error: error.message,
                duration: 0,
            });
            console.log(chalk.yellow(`     âš  Simulation error: ${finding.title} â€” ${error.message}`));
        }
    }

    report.totalDuration = Date.now() - startTime;
    console.log(chalk.cyan(
        `   âœ“ Simulation complete: ${report.confirmedVulnerabilities} confirmed, ` +
        `${report.deniedVulnerabilities} denied (${(report.totalDuration / 1000).toFixed(1)}s)`,
    ));

    return report;
}

// â”€â”€â”€ Single Finding Simulation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function simulateSingleFinding(
    finding: VulnerabilityFinding,
    intel: ContractIntel,
    code: string,
    rpcUrl: string,
    testDir: string,
): Promise<SimulationResult> {
    const startTime = Date.now();

    // 1. Generate the test via AI
    const testCode = await generateExploitTest(finding, intel, code);

    // 2. Write test file
    const testFileName = `Test_${sanitizeFilename(finding.id)}.t.sol`;
    const testFilePath = path.join(testDir, testFileName);
    fs.writeFileSync(testFilePath, testCode);

    // 3. Run forge test on fork
    let output = '';
    let passed = false;
    let gasUsed: number | undefined;

    try {
        const result = execSync(
            `forge test --match-path test/${testFileName} --fork-url "${rpcUrl}" -vvv --no-match-test "testFail" 2>&1`,
            {
                cwd: SIMULATION_DIR,
                timeout: 120000, // 2 min timeout
                env: { ...process.env, RPC_URL: rpcUrl },
                maxBuffer: 5 * 1024 * 1024,
            },
        );
        output = result.toString();

        // Parse results
        passed = output.includes('PASS') || output.includes('[PASS]');

        // Extract gas if available
        const gasMatch = output.match(/gas:\s*(\d+)/);
        if (gasMatch) gasUsed = parseInt(gasMatch[1]);

    } catch (err: any) {
        output = err.stdout?.toString() || err.stderr?.toString() || err.message;

        // Forge exits with non-zero when tests fail, but that means
        // the exploit DIDN'T work, which is actually good
        passed = false;
    }

    // 4. Cleanup test file
    try { fs.unlinkSync(testFilePath); } catch { }

    return {
        finding,
        testCode,
        passed,
        output: output.substring(0, 3000), // Cap output size
        gasUsed,
        duration: Date.now() - startTime,
    };
}

// â”€â”€â”€ AI Test Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function generateExploitTest(
    finding: VulnerabilityFinding,
    intel: ContractIntel,
    code: string,
): Promise<string> {
    const model = process.env.AI_MODEL || 'google/gemini-2.0-flash-exp:free';

    const abiInfo = intel.abi.length > 0
        ? `ABI:\n${JSON.stringify(intel.abi.slice(0, 20), null, 2)}`
        : `Detected functions:\n${intel.detectedFunctions.map(f => `  ${f.signature || f.selector}`).join('\n')}`;

    const prompt = `You are a Solidity security researcher. Generate a Foundry test that attempts to exploit the following vulnerability on a forked chain.

CONTRACT ADDRESS: ${intel.address}
CONTRACT NAME: ${intel.contractName}
CHAIN: ${intel.chain}
BALANCE: ${intel.balance} ETH
${intel.owner ? `OWNER: ${intel.owner}` : ''}
${intel.tokenInfo ? `TOKEN: ${intel.tokenInfo.standard} ${intel.tokenInfo.name} (${intel.tokenInfo.symbol})` : ''}

${abiInfo}

VULNERABILITY:
- Category: ${finding.category}
- Severity: ${finding.severity}
- Title: ${finding.title}
- Description: ${finding.description}
${finding.affectedFunction ? `- Affected Function: ${finding.affectedFunction}` : ''}

SOURCE CODE (may be partial/decompiled):
\`\`\`solidity
${code.substring(0, 6000)}
\`\`\`

Generate a complete Foundry test contract. Requirements:
1. Import "forge-std/Test.sol"
2. Use vm.createSelectFork() or fork via command-line
3. The test MUST interact with the contract at ${intel.address} on the fork
4. If the exploit succeeds, the test should PASS (assert the exploit worked)
5. If the exploit fails, the test should REVERT or fail assertions
6. Use vm.prank() for impersonation if needed
7. Use vm.deal() to fund the attacker with ETH if needed
8. Include clear comments explaining the attack steps
9. Keep it minimal â€” one test function, one clear exploit path

CRITICAL: The attack address is ${intel.address}. This is a FORK test â€” no real funds are at risk.

Output ONLY the Solidity code, no markdown formatting or explanation.`;

    try {
        const response = await getOpenAI().chat.completions.create({
            model,
            messages: [
                {
                    role: 'system',
                    content: 'You are an expert Solidity security researcher. Generate only clean, compilable Foundry test code. No markdown, no explanations â€” just code.',
                },
                { role: 'user', content: prompt },
            ],
        });

        let testCode = response.choices[0].message.content || '';

        // Strip markdown code fences if AI included them
        testCode = testCode.replace(/^```solidity\n?/m, '').replace(/^```\n?/m, '').replace(/```$/m, '');

        // Ensure it has a minimum valid structure
        if (!testCode.includes('import') || !testCode.includes('function test')) {
            throw new Error('Generated test is not valid Solidity');
        }

        return testCode;
    } catch (err) {
        // Fallback: generate a basic interaction test
        return generateFallbackTest(finding, intel);
    }
}

function generateFallbackTest(finding: VulnerabilityFinding, intel: ContractIntel): string {
    return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

contract ExploitTest_${sanitizeFilename(finding.id)} is Test {
    address constant TARGET = ${intel.address};
    address attacker;

    function setUp() public {
        attacker = makeAddr("attacker");
        vm.deal(attacker, 10 ether);
    }

    function testExploit_${sanitizeFilename(finding.category)}() public {
        vm.startPrank(attacker);

        // Attempt basic interaction â€” ${finding.title}
        // Category: ${finding.category}
        (bool success, ) = TARGET.call{value: 0}(abi.encodeWithSignature("${finding.affectedFunction || 'owner()'}"));
        
        // If the call succeeds with unexpected results, it may indicate a vulnerability
        assertTrue(success, "Basic call should succeed");

        vm.stopPrank();
    }
}
`;
}

// â”€â”€â”€ Extract Findings from Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Extract testable vulnerability findings from analysis results.
 * Called by the agent after running the 4 analysis modules.
 */
export async function extractFindings(
    code: string,
    contractName: string,
    intel: ContractIntel,
): Promise<VulnerabilityFinding[]> {
    const model = process.env.AI_MODEL || 'google/gemini-2.0-flash-exp:free';

    const contextLines = [
        `Contract: ${contractName} at ${intel.address}`,
        `Chain: ${intel.chain}`,
        `Balance: ${intel.balance} ETH`,
        `Bytecode size: ${intel.bytecodeSize} bytes`,
        intel.isProxy ? `PROXY â†’ ${intel.implementationAddress}` : null,
        intel.tokenInfo ? `Token: ${intel.tokenInfo.standard} ${intel.tokenInfo.name}` : null,
        intel.owner ? `Owner: ${intel.owner}` : null,
        intel.totalTxCount ? `Total txs: ${intel.totalTxCount}` : null,
    ].filter(Boolean).join('\n');

    const prompt = `You are an advanced smart contract security auditor. Analyze the following contract for vulnerabilities that can be demonstrated on a forked chain.

CONTEXT:
${contextLines}

SOURCE / DECOMPILED:
\`\`\`solidity
${code.substring(0, 8000)}
\`\`\`

Find ALL exploitable vulnerabilities. For each, provide:
- id: unique snake_case identifier
- category: one of [reentrancy, access-control, integer-overflow, unchecked-return, delegatecall, selfdestruct, frontrunning, oracle-manipulation, flash-loan, approval-abuse, storage-collision, logic-error, dos-gas, price-manipulation, signature-replay, timestamp-dependence]
- severity: CRITICAL | HIGH | MEDIUM | LOW | INFO
- title: short title
- description: detailed explanation of the vulnerability and how it can be exploited
- affectedFunction: the function name most affected
- recommendation: how to fix it

Respond with a JSON array of findings. Only include vulnerabilities that have a realistic exploit path. Do not include best practices or gas optimizations.

Output ONLY the JSON array, no markdown or explanation.`;

    try {
        const response = await getOpenAI().chat.completions.create({
            model,
            messages: [
                { role: 'system', content: 'You are an expert smart contract auditor. Output only valid JSON arrays.' },
                { role: 'user', content: prompt },
            ],
        });

        let content = response.choices[0].message.content || '[]';
        // Strip markdown fences
        content = content.replace(/^```json\n?/m, '').replace(/^```\n?/m, '').replace(/```$/m, '').trim();

        const findings: VulnerabilityFinding[] = JSON.parse(content);
        return findings.filter(f => f.id && f.category && f.severity && f.title);
    } catch (err) {
        console.log(chalk.yellow(`   âš  Finding extraction failed: ${(err as Error).message}`));
        return [];
    }
}

// â”€â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function sanitizeFilename(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').substring(0, 50);
}
