import { ReActTool } from './index';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execAsync = promisify(exec);

export class ExecuteExploitTool implements ReActTool {
    definition = {
        name: 'execute_exploit',
        description: 'Compiles and runs a Foundry test file (Exploit.t.sol) against a forked network to confirm if an exploit works (EVM Only). Includes self-healing if compilation fails.',
        parameters: {
            type: 'object',
            properties: {
                testCode: {
                    type: 'string',
                    description: 'The complete Solidity code for the Foundry test (Exploit.t.sol).',
                },
                targetCode: {
                    type: 'string',
                    description: 'The source code of the vulnerable contract (Target.sol) needed for compilation alongside the test.',
                },
                rpcUrl: {
                    type: 'string',
                    description: 'The RPC URL to fork for testing.',
                },
                forkBlock: {
                    type: 'string',
                    description: 'Optional block number to fork at.',
                }
            },
            required: ['testCode', 'targetCode', 'rpcUrl'],
        },
    };

    async execute(args: { testCode: string; targetCode: string; rpcUrl: string; forkBlock?: string }): Promise<string> {
        if (!args.testCode || !args.targetCode || !args.rpcUrl) {
            return 'Error: Missing required arguments.';
        }

        try {
            // Write files to a temporary directory
            const tmpDir = path.join(process.cwd(), '.vibe_tmp', `react_${Date.now()}`);
            await fs.mkdir(path.join(tmpDir, 'src'), { recursive: true });
            await fs.mkdir(path.join(tmpDir, 'test'), { recursive: true });

            // Write foundry.toml
            const foundryToml = `
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
test = "test"
cache_path = "cache"
optimizer = true
optimizer_runs = 200
`;
            await fs.writeFile(path.join(tmpDir, 'foundry.toml'), foundryToml);

            // Add remappings and symlink lib
            await fs.writeFile(path.join(tmpDir, 'remappings.txt'), 'forge-std/=lib/forge-std/src/');
            try {
                await fs.symlink(path.join(process.cwd(), '.vibeaudit-pipeline', 'lib'), path.join(tmpDir, 'lib'), 'dir');
            } catch (e) {
                // If symlink fails (e.g., windows), ignore and let forge fail naturally or fallback
            }

            // Write target and test files
            await fs.writeFile(path.join(tmpDir, 'src', 'Target.sol'), args.targetCode);
            await fs.writeFile(path.join(tmpDir, 'test', 'Exploit.t.sol'), args.testCode);

            // Execute forge test
            let forgeCmd = `forge test --root ${tmpDir}`;
            if (args.rpcUrl && args.rpcUrl !== 'none') {
                forgeCmd += ` --fork-url ${args.rpcUrl}`;
                if (args.forkBlock && args.forkBlock !== 'latest') {
                    forgeCmd += ` --fork-block-number ${args.forkBlock}`;
                }
            }

            let output = '';
            let passed = false;

            try {
                const { stdout, stderr } = await execAsync(forgeCmd, { timeout: 60000 });
                output = stdout + '\n' + stderr;
                passed = stdout.includes('PASS') && !stdout.includes('FAIL');
            } catch (execError: any) {
                output = execError.stdout + '\n' + execError.stderr;
                passed = false;
            }

            // Cleanup
            await fs.rm(tmpDir, { recursive: true, force: true }).catch(() => { });

            let resultString = `Execution Result: ${passed ? '✅ PASSED (Exploit Confirmed)' : '❌ FAILED'}\n\n`;
            if (output) {
                // Truncate output to avoid overwhelming the LLM context
                const lines = output.split('\n');
                if (lines.length > 50) {
                    resultString += `Compiler/Execution Output (truncated):\n${lines.slice(0, 20).join('\n')}\n...\n${lines.slice(-30).join('\n')}\n`;
                } else {
                    resultString += `Compiler/Execution Output:\n${output}\n`;
                }
            }

            return resultString;
        } catch (error) {
            return `Error executing execute_exploit: ${(error as Error).message}`;
        }
    }
}
