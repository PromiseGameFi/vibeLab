import { ReActTool } from './index';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import OpenAI from 'openai';
import { getProvider, getChainType } from '../../../chains';
import { requireApproval } from '../../approval';
import { cleanupDir, parseForgeOutput, prepareFoundryWorkspace } from './foundry-utils';

const execAsync = promisify(exec);

interface ExecuteArgs {
    runId: string;
    chain: string;
    testCode?: string;
    targetCode?: string;
    rpcUrl?: string;
    forkBlock?: string;
    maxRetries?: number;
    simulationInput?: {
        to?: string;
        from?: string;
        data?: string;
        value?: string;
        blockTag?: string | number;
        rawTransactionBase64?: string;
        sender?: string;
        transactionBlock?: string;
        payload?: Record<string, unknown>;
    };
}

async function repairExploitCode(originalCode: string, compilerOutput: string): Promise<string> {
    const client = new OpenAI({
        apiKey: process.env.GROQ_API_KEY || 'dummy',
        baseURL: 'https://api.groq.com/openai/v1',
    });

    const prompt = `Fix this Foundry exploit test code so it compiles and preserves exploit intent.

Compiler output:
${compilerOutput}

Original code:
${originalCode}

Return only corrected Solidity code.`;

    const completion = await client.chat.completions.create({
        model: process.env.AI_MODEL || 'llama-3.3-70b-versatile',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.1,
    });

    const fixed = completion.choices[0]?.message?.content || '';
    return fixed.replace(/```solidity/g, '').replace(/```/g, '').trim() || originalCode;
}

export class ExecuteExploitTool implements ReActTool {
    definition = {
        name: 'execute_exploit',
        description: 'Execute exploit validation with approval-gated EVM Foundry execution or non-EVM live simulation.',
        parameters: {
            type: 'object',
            properties: {
                runId: {
                    type: 'string',
                    description: 'The unique engagement run id.',
                },
                chain: {
                    type: 'string',
                    description: 'Target chain name (ethereum, base, solana, sui, etc.).',
                },
                testCode: {
                    type: 'string',
                    description: 'Foundry exploit test source for EVM validation.',
                },
                targetCode: {
                    type: 'string',
                    description: 'Target contract source for EVM validation.',
                },
                rpcUrl: {
                    type: 'string',
                    description: 'RPC URL override.',
                },
                forkBlock: {
                    type: 'string',
                    description: 'Optional fork block number for EVM execution.',
                },
                maxRetries: {
                    type: 'integer',
                    description: 'Maximum auto-repair retries on compiler failure. Default 3.',
                },
                simulationInput: {
                    type: 'object',
                    description: 'Optional simulation payload for non-EVM chains.',
                },
            },
            required: ['runId', 'chain'],
        },
    };

    async execute(args: ExecuteArgs): Promise<string> {
        if (!args.runId || !args.chain) {
            return JSON.stringify({ ok: false, error: 'Missing required runId or chain.' });
        }

        const isEvm = getChainType(args.chain) === 'evm';
        const approvalScope = isEvm ? 'execute_exploit' : 'chain_simulation';
        const approval = requireApproval(args.runId, approvalScope);
        if (!approval.ok) {
            return JSON.stringify({ ok: false, approvalRequired: true, error: approval.error });
        }

        if (!isEvm) {
            try {
                const provider = await getProvider(args.chain, args.rpcUrl);
                const result = await provider.simulateAction({
                    chain: args.chain,
                    to: args.simulationInput?.to,
                    from: args.simulationInput?.from,
                    data: args.simulationInput?.data,
                    value: args.simulationInput?.value,
                    blockTag: args.simulationInput?.blockTag,
                    rawTransactionBase64: args.simulationInput?.rawTransactionBase64,
                    sender: args.simulationInput?.sender,
                    transactionBlock: args.simulationInput?.transactionBlock,
                    payload: args.simulationInput?.payload,
                });

                return JSON.stringify({
                    ok: true,
                    runId: args.runId,
                    chain: args.chain,
                    mode: 'simulation',
                    result,
                });
            } catch (error) {
                return JSON.stringify({
                    ok: false,
                    runId: args.runId,
                    chain: args.chain,
                    mode: 'simulation',
                    error: (error as Error).message,
                });
            }
        }

        if (!args.testCode || !args.targetCode || !args.rpcUrl) {
            return JSON.stringify({
                ok: false,
                error: 'EVM execution requires testCode, targetCode, and rpcUrl.',
            });
        }

        const maxRetries = Math.max(0, args.maxRetries ?? 3);
        let currentCode = args.testCode;

        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            const tmpDir = path.join(process.cwd(), '.vibe_tmp', `react_${Date.now()}_${attempt}`);

            try {
                await prepareFoundryWorkspace(tmpDir, `
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
test = "test"
cache_path = "cache"
optimizer = true
optimizer_runs = 200
`);

                await fs.writeFile(path.join(tmpDir, 'src', 'Target.sol'), args.targetCode, 'utf8');
                await fs.writeFile(path.join(tmpDir, 'test', 'Exploit.t.sol'), currentCode, 'utf8');

                let forgeCmd = `forge test --root ${tmpDir}`;
                forgeCmd += ` --fork-url ${args.rpcUrl}`;
                if (args.forkBlock && args.forkBlock !== 'latest') {
                    forgeCmd += ` --fork-block-number ${args.forkBlock}`;
                }

                const { stdout, stderr } = await execAsync(forgeCmd, { timeout: 90000 })
                    .catch((execError: any) => ({
                        stdout: execError.stdout || '',
                        stderr: execError.stderr || '',
                    }));

                const output = `${stdout}\n${stderr}`;
                const parsed = parseForgeOutput(output);

                if (parsed.passed) {
                    await cleanupDir(tmpDir);
                    return JSON.stringify({
                        ok: true,
                        runId: args.runId,
                        chain: args.chain,
                        mode: 'evm_foundry',
                        passed: true,
                        attempts: attempt + 1,
                        output: output.length > 8000 ? `${output.substring(0, 8000)}\n...[TRUNCATED]` : output,
                        testCode: currentCode,
                    });
                }

                if (parsed.hasCompilerError && attempt < maxRetries) {
                    currentCode = await repairExploitCode(currentCode, output);
                    await cleanupDir(tmpDir);
                    continue;
                }

                await cleanupDir(tmpDir);
                return JSON.stringify({
                    ok: true,
                    runId: args.runId,
                    chain: args.chain,
                    mode: 'evm_foundry',
                    passed: false,
                    attempts: attempt + 1,
                    hasCompilerError: parsed.hasCompilerError,
                    failureReason: parsed.failureReason,
                    output: output.length > 8000 ? `${output.substring(0, 8000)}\n...[TRUNCATED]` : output,
                    testCode: currentCode,
                });
            } catch (error) {
                await cleanupDir(tmpDir);
                if (attempt >= maxRetries) {
                    return JSON.stringify({
                        ok: false,
                        runId: args.runId,
                        chain: args.chain,
                        mode: 'evm_foundry',
                        error: (error as Error).message,
                    });
                }
            }
        }

        return JSON.stringify({
            ok: false,
            runId: args.runId,
            chain: args.chain,
            error: 'Execution failed after retries.',
        });
    }
}
