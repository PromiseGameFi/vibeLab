import { ReActTool } from './index';
import { executeWithHealing } from '../../../pipeline/executor';

export class ExecuteExploitTool implements ReActTool {
    definition = {
        name: 'execute_exploit',
        description: 'Compiles and runs a Foundry test file (Exploit.t.sol) against a forked network to confirm if an exploit works (EVM Only). Includes self-healing if compilation fails.',
        parameters: {
            type: 'object',
            properties: {
                testCode: {
                    type: 'string',
                    description: 'The complete Solidity code for the Foundry test (Exploit.t.sol).',
                },
                targetCode: {
                    type: 'string',
                    description: 'The source code of the vulnerable contract (Target.sol) needed for compilation alongside the test.',
                },
                rpcUrl: {
                    type: 'string',
                    description: 'The RPC URL to fork for testing.',
                },
                forkBlock: {
                    type: 'string',
                    description: 'Optional block number to fork at.',
                }
            },
            required: ['testCode', 'targetCode', 'rpcUrl'],
        },
    };

    async execute(args: { testCode: string; targetCode: string; rpcUrl: string; forkBlock?: string }): Promise<string> {
        if (!args.testCode || !args.targetCode || !args.rpcUrl) {
            return 'Error: Missing required arguments.';
        }

        try {
            // Mock exploit object for the executor
            const mockExploits = [{
                strategyId: 'EXP-TOOL',
                title: 'ReAct Generated Exploit',
                testCode: args.testCode,
                filename: 'Exploit.t.sol',
                targetSourceNeeded: true,
            }];

            const results = await executeWithHealing(mockExploits, args.targetCode, 'Target.sol', {
                rpcUrl: args.rpcUrl,
                maxRetries: 3,
                forkBlock: args.forkBlock,
            });

            if (results.length === 0) {
                return 'Error: Execution returned no results.';
            }

            const result = results[0];
            let output = `Execution Result: ${result.passed ? '✅ PASSED (Exploit Confirmed)' : '❌ FAILED'}\n\n`;

            if (result.finalOutput) {
                output += `Compiler/Execution Output:\n${result.finalOutput}\n`;
            }

            if (result.error) {
                output += `\nError:\n${result.error}\n`;
            }

            return output;
        } catch (error) {
            return `Error executing execute_exploit: ${(error as Error).message}`;
        }
    }
}
