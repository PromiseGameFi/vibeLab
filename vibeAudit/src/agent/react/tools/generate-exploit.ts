import { ReActTool } from './index';
import OpenAI from 'openai';

export class GenerateExploitTool implements ReActTool {
    definition = {
        name: 'generate_exploit',
        description: 'Generates Foundry exploit test code for a specific EVM vulnerability and returns a structured JSON payload.',
        parameters: {
            type: 'object',
            properties: {
                runId: {
                    type: 'string',
                    description: 'The unique engagement run id.',
                },
                vulnerabilityTitle: {
                    type: 'string',
                    description: 'Title or short name of the vulnerability to exploit.',
                },
                vulnerabilityDescription: {
                    type: 'string',
                    description: 'Detailed explanation of how the vulnerability works and how to exploit it.',
                },
                targetCode: {
                    type: 'string',
                    description: 'The source code of the vulnerable contract.',
                },
            },
            required: ['runId', 'vulnerabilityTitle', 'vulnerabilityDescription', 'targetCode'],
        },
    };

    async execute(args: {
        runId: string;
        vulnerabilityTitle: string;
        vulnerabilityDescription: string;
        targetCode: string;
    }): Promise<string> {
        if (!args.runId || !args.vulnerabilityTitle || !args.vulnerabilityDescription || !args.targetCode) {
            return JSON.stringify({
                ok: false,
                error: 'Missing required arguments.',
            });
        }

        try {
            const openai = new OpenAI({
                apiKey: process.env.GROQ_API_KEY || 'dummy',
                baseURL: 'https://api.groq.com/openai/v1',
            });

            const prompt = `You are an elite smart contract security auditor. Write a complete executable Foundry test (Exploit.t.sol).

Vulnerability: ${args.vulnerabilityTitle}
Description: ${args.vulnerabilityDescription}

Target source code:\n\n${args.targetCode}\n
Return ONLY Solidity code without markdown fences.`;

            const completion = await openai.chat.completions.create({
                model: process.env.AI_MODEL || 'llama-3.3-70b-versatile',
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.1,
            });

            const response = completion.choices[0]?.message?.content || '';
            const testCode = response.replace(/```solidity|```/g, '').trim();

            if (!testCode) {
                return JSON.stringify({ ok: false, error: 'Failed to generate exploit code.' });
            }

            return JSON.stringify({
                ok: true,
                runId: args.runId,
                vulnerabilityTitle: args.vulnerabilityTitle,
                testCode,
                language: 'solidity',
                generatedAt: new Date().toISOString(),
            });
        } catch (error) {
            return JSON.stringify({ ok: false, error: `Error executing generate_exploit: ${(error as Error).message}` });
        }
    }
}
