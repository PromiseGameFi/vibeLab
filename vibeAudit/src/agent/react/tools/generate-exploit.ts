import { ReActTool } from './index';
// Re-using the exploit-gen logic
import { generateExploits } from '../../../pipeline/exploit-gen';
import { AttackStrategy } from '../../../pipeline/strategy';

export class GenerateExploitTool implements ReActTool {
    definition = {
        name: 'generate_exploit',
        description: 'Generates a complete executable Foundry test file (Exploit.t.sol) to prove a specific vulnerability on an EVM chain.',
        parameters: {
            type: 'object',
            properties: {
                vulnerabilityTitle: {
                    type: 'string',
                    description: 'Title or short name of the vulnerability to exploit.',
                },
                vulnerabilityDescription: {
                    type: 'string',
                    description: 'Detailed explanation of how the vulnerability works and how to exploit it.',
                },
                targetCode: {
                    type: 'string',
                    description: 'The source code of the vulnerable contract.',
                }
            },
            required: ['vulnerabilityTitle', 'vulnerabilityDescription', 'targetCode'],
        },
    };

    async execute(args: { vulnerabilityTitle: string; vulnerabilityDescription: string; targetCode: string }): Promise<string> {
        if (!args.vulnerabilityTitle || !args.vulnerabilityDescription || !args.targetCode) {
            return 'Error: Missing required arguments.';
        }

        try {
            // Mock a strategy object to feed into the generator
            const dummyStrategy: AttackStrategy = {
                id: `EXP-${Date.now()}`,
                title: args.vulnerabilityTitle,
                category: 'Authentication',
                severity: 'HIGH',
                score: 90,
                profitPotential: 'Unknown',
                steps: ['Setup environment', 'Execute exploit', 'Verify profit'],
                affectedFunctions: [],
                exploitCode: '',
                prerequisites: [],
                sources: [],
                relatedFindings: [],
            };

            // Mock recon object â€” we don't have full recon in this tool context, but exploit-gen needs some fields
            const dummyRecon: any = {
                name: 'TargetContract',
                solidityVersion: '^0.8.0',
            };

            const exploits = await generateExploits([dummyStrategy], args.targetCode, dummyRecon, 1);

            if (exploits.length > 0 && exploits[0].testCode) {
                return `Generated Foundry Exploit Code:\n\n\`\`\`solidity\n${exploits[0].testCode}\n\`\`\``;
            }

            return 'Error: Failed to generate exploit code.';
        } catch (error) {
            return `Error executing generate_exploit: ${(error as Error).message}`;
        }
    }
}
