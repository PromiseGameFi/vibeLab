/**
 * Stage 5: Exploit Generation
 * Generate high-quality Foundry test code from attack strategies.
 * Handles imports, attacker contracts, and proper test structure.
 */

import OpenAI from 'openai';
import dotenv from 'dotenv';
import { AttackStrategy } from './strategy';
import { ContractRecon } from './recon';

dotenv.config();

let _openai: OpenAI | null = null;
function getOpenAI(): OpenAI {
    if (!_openai) {
        _openai = new OpenAI({
            apiKey: process.env.GROQ_API_KEY || 'dummy',
            baseURL: 'https://api.groq.com/openai/v1',
            defaultHeaders: {
                'HTTP-Referer': 'https://vibelab.app',
                'X-Title': 'VibeAudit',
            },
        });
    }
    return _openai;
}

export interface GeneratedExploit {
    strategyId: string;
    title: string;
    testCode: string;         // Complete Foundry test file
    filename: string;         // Suggested filename
    targetSourceNeeded: boolean;
}

const EXPLOIT_GEN_PROMPT = `You are a Foundry exploit test generator. You receive an attack strategy and the target contract source code. You MUST produce a COMPLETE, COMPILABLE Foundry test file.

RULES:
1. Import forge-std/Test.sol
2. Import or inline the target contract (use the exact source)
3. Create any attacker/helper contracts needed (e.g., for reentrancy callbacks)
4. setUp() should deploy the target and fund it with ETH/tokens as needed
5. The test function MUST be named test_exploit() and MUST:
   - Start from the attacker's position
   - Execute the full attack
   - Assert that the attacker PROFITED (use assertGt)
6. Use vm.deal() to give the attacker and contract starting ETH
7. Use vm.prank() or vm.startPrank() for caller impersonation
8. EVERY test must be self-contained and runnable with: forge test --match-test test_exploit -vvv

RESPOND WITH ONLY THE SOLIDITY CODE, no explanation. Start with // SPDX-License-Identifier`;

/**
 * Generate exploit code for a strategy.
 * If the strategy already has quality exploit code, use it directly.
 * Otherwise, use AI to generate a proper test.
 */
export async function generateExploit(
    strategy: AttackStrategy,
    contractCode: string,
    recon: ContractRecon,
): Promise<GeneratedExploit> {
    // If the strategy already has substantial exploit code, wrap it properly
    if (strategy.exploitCode && strategy.exploitCode.length > 200 &&
        strategy.exploitCode.includes('Test') && strategy.exploitCode.includes('function')) {
        return {
            strategyId: strategy.id,
            title: strategy.title,
            testCode: strategy.exploitCode,
            filename: `Exploit_${sanitize(strategy.id)}.t.sol`,
            targetSourceNeeded: true,
        };
    }

    // Otherwise, generate via AI
    const model = process.env.AI_MODEL || 'llama-3.3-70b-versatile';

    const userMessage = `
=== ATTACK STRATEGY ===
ID: ${strategy.id}
Title: ${strategy.title}
Severity: ${strategy.severity}
Category: ${strategy.category}
Steps: ${strategy.steps.join(' â†’ ')}
Profit Potential: ${strategy.profitPotential}
Affected Functions: ${strategy.affectedFunctions.join(', ')}
Prerequisites: ${strategy.prerequisites.join(', ') || 'None'}

=== EXISTING EXPLOIT SKETCH ===
${strategy.exploitCode || 'None provided'}

=== TARGET CONTRACT (${recon.name}) ===
${contractCode}

Generate a COMPLETE Foundry test file that exploits this vulnerability.`;

    try {
        const response = await getOpenAI().chat.completions.create({
            model,
            messages: [
                { role: 'system', content: EXPLOIT_GEN_PROMPT },
                { role: 'user', content: userMessage },
            ],
        });

        let testCode = response.choices[0].message.content || '';
        testCode = testCode.replace(/```solidity/g, '').replace(/```/g, '').trim();

        // Ensure it starts with SPDX
        if (!testCode.startsWith('//')) {
            testCode = '// SPDX-License-Identifier: MIT\n' + testCode;
        }

        return {
            strategyId: strategy.id,
            title: strategy.title,
            testCode,
            filename: `Exploit_${sanitize(strategy.id)}.t.sol`,
            targetSourceNeeded: true,
        };
    } catch (error) {
        // Fallback: use whatever exploit code we have
        return {
            strategyId: strategy.id,
            title: strategy.title,
            testCode: strategy.exploitCode || `// Failed to generate exploit for: ${strategy.title}`,
            filename: `Exploit_${sanitize(strategy.id)}.t.sol`,
            targetSourceNeeded: true,
        };
    }
}

/**
 * Generate exploits for multiple strategies (top N by score).
 */
export async function generateExploits(
    strategies: AttackStrategy[],
    contractCode: string,
    recon: ContractRecon,
    maxExploits: number = 10,
): Promise<GeneratedExploit[]> {
    // Only generate for top strategies that have meaningful content
    const toGenerate = strategies
        .filter(s => s.severity !== 'MEDIUM' || s.score >= 50)
        .slice(0, maxExploits);

    const exploits: GeneratedExploit[] = [];

    for (const strategy of toGenerate) {
        const exploit = await generateExploit(strategy, contractCode, recon);
        exploits.push(exploit);
    }

    return exploits;
}

function sanitize(name: string): string {
    return name.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
}
